# -*- coding: utf-8 -*-
"""EKG

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pEeotTIE3l6jJrxuW_3xaf29lHXwUEwq

# Rejestracja i analiza sygnału EKG

## Wprowadzenie [1]
Serce posiada specjalny, wzbudzany samoczynnie układ, który generuje i przewodzi bodźce elektryczne. Następstwem działania tego układu jest rytmiczna praca serca o częstości od 70 do 180 cykli na minutę (częstość ta ulega zmianom pod wpływem czynników biochemicznych, powstałych np. w skutek stresu).

Elektrody pomiarowe połączone do aparatury rejestrujących sygnał nazywamy odprowadzeniami.

Zastosowano klasyczne odprowadzenia:
* Trzy odprowadzenia Einthovena oznaczane cyframi rzymskimi $ I, II, III $. Elektrody w tym systemie umieszcza się na prawej (R) i lewej (L) ręce w okolicy nadgarstka oraz na lewej nodze (F) w okolicy stopy. Odprowadzenia kończynowe mierzą różnicę napięć pomiędzy miejscami przyłożenia elektrod następująco:

 $ I = V_L - V_R $

 $ II = V_F - V_R $

 $ III = V_F - V_L $

* Trzy odprowadzenia jednobiegunowe Goldberga. W odprowadzeniach tych sygnał w danym odprowadzeniu jest różnicą napięć pomiędzy elektrodą pomiarową, a średnim napięciem na dwóch pozostałych elektrodach: 

 $ aV_R = V_R - \frac{V_L + V_F}{2} $

 $ aV_R = V_R - \frac{V_L + V_F}{2} $

 $ aV_R = V_R - \frac{V_L + V_F}{2} $

Przed dokonaniem pomiarów przyklejono elektrody do badanego, przewody podłączono do elektrod, a następnie do wzmacniacza. Podłączono również zasilanie wzmacniacza, który podłączono do komputera. Sygnał zbierano w programie SVAROG.

## Ćwiczenia 1-3
Umieszczono po jednej elektrodzie na prawej i lewej kończynie górnej oraz w okolicy kostki na lewej nodze. Korzystajac z zakładki "Montaż" w programie SVAROG utworzono odprowadzenia Einthovena. Zebrano fragmenty sygnału EKG dla różnych stanów biochemicznych z częstością próbkowania 128 Hz. Omawiane stany to:
* spoczynek,
* oglądanie stresującego/pobudzającego filmu (horror),
* stan po wysiłku fizycznym.

##Ćwiczenie 4 - Wstępna obróbka sygnału EKG

Na początek zaimportowano niezbędne biblioteki oraz wczytano sygnał zebrany w trakcie spoczynku.
Następnie zmontowano sygnał stosując odprowadzenia Einthovena oraz Goldberga.
"""

import numpy as np
import scipy as sc
import matplotlib.pyplot as plt
from  scipy.signal import freqz, group_delay
from  scipy.signal import lfilter, filtfilt
from  scipy.signal import firwin, firwin2   
from  scipy.signal import butter, buttord     
from  scipy.signal import cheby1, cheb1ord    
from  scipy.signal import cheby2, cheb2ord 
from  scipy.signal import find_peaks
import more_itertools as mit

n_ch = 3
with open('syg_rest.raw', 'rb') as f_out:
    syg = np.fromfile(f_out, dtype='float32')
syg *= 0.0715 # przemnożono sygnał zgodnie z informacją z pliku .xml
syg = np.reshape(syg,(len(syg)//n_ch,n_ch))

VR =syg[:,0]
VL =syg[:,1]
VF =syg[:,2]

#Einthoven
syg_1 = VL - VR
syg_2 = VF - VR
syg_3 = VF - VL

#Goldberg
syg_1_g = VL - ((VR+VF)/2)
syg_2_g = VR - ((VF+VL)/2)
syg_3_g = VF - ((VL+VR)/2)

Fs = 128
T = len(syg_1)/Fs
dt = 1/Fs
t = np.arange(0,T,dt)

x1 = 500 # czas od
x2 = 1000 # do

plt.figure(figsize=(10,6), dpi= 100, facecolor='w', edgecolor='k')

plt.subplot(3,2,1)
plt.plot(t[x1:x2], syg_1[x1:x2])
plt.title("Zmontowane fragmenty sygnału (Einthoven)")
plt.ylabel("Napięcie[mV]")
plt.grid(True)

plt.subplot(3,2,2)
plt.plot(t[x1:x2], syg_1_g[x1:x2])
plt.title("Zmontowane fragmenty sygnału (Goldberg)")
plt.grid(True)

plt.subplot(3,2,3)
plt.plot(t[x1:x2], syg_2[x1:x2])
plt.ylabel("Napięcie[mV]")
plt.grid(True)

plt.subplot(3,2,4)
plt.plot(t[x1:x2], syg_2_g[x1:x2])
plt.grid(True)

plt.subplot(3,2,5)
plt.plot(t[x1:x2], syg_3[x1:x2])
plt.ylabel("Napięcie[mV]")
plt.xlabel("Czas [s]")
plt.grid(True)

plt.subplot(3,2,6)
plt.plot(t[x1:x2], syg_3_g[x1:x2])
plt.xlabel("Czas [s]")
plt.grid(True)
plt.show()

"""W następnym kroku wykonano stosowne filtracje (z zerowym przesunięciem fazowym) oraz wyrysowano charakterystyki zastosowanych filtrów."""

# funkcja charakterystyki filtra
def charkterystyki(a,b,f,T,Fs, f_lim = None):
    if f_lim == None:
      f_lim = (0, Fs/2)
    t = np.arange(-T, T, 1/Fs)
    f, h = freqz(b,a,f,fs = Fs) 
    m = np.abs(h)
    faza = np.unwrap(np.angle(h))
    w = 2*np.pi*f/Fs 
  
    ff, grupowe = group_delay((b, a), f,fs=Fs)
    x = np.zeros(len(t))
    x[len(t)//2] = 1
    y = lfilter(b,a,x)
    s = np.zeros(len(t))
    s[len(t)//2:] = 1
    ys = lfilter(b,a,s)
    
    # wykresy
    fig = plt.figure()
    plt.subplot(2,2,1)
    plt.title('moduł transmitancji')
    M = 20*np.log10(m)
    plt.plot(f,M)
    plt.ylabel('[dB]')
    plt.grid('on')
    plt.xlim(f_lim)
    M_zoom = M[np.logical_and( f_lim[0]<f , f<f_lim[1])]
    plt.ylim((np.min(M_zoom), np.max(M_zoom)))
    
    plt.subplot(2,2,3)
    plt.title('opóźnienie grupowe')
    plt.plot(f,grupowe)
    plt.ylabel('probki')
    plt.xlabel('Częstość [Hz]')
    plt.grid('on')
    plt.xlim(f_lim)
    plt.ylim([np.min(grupowe)-1, np.max(grupowe)+1])
    
    plt.subplot(2,2,2)
    plt.title('odpowiedź impulsowa')
    plt.plot(t, x)
    plt.plot(t, y)
    plt.xlim([-T/4,T])
    plt.grid('on')
    
    plt.subplot(2,2,4)
    plt.title('odpowiedź schodkowa')
    plt.plot(t, s)
    plt.plot(t, ys)
    plt.xlim([-T/4,T])
    plt.xlabel('Czas [s]')
    plt.grid('on')
    
    fig.subplots_adjust(hspace=.5)
    plt.show()

# filtrowanie

# filtr górnoprzepustowy Butterwortha 1 rzędu z częstością odcięcia 0.25 Hz
[b,a] = butter(1,0.25, btype='highpass', fs=Fs)
f = np.arange(0.01,Fs/2,0.01)
T = 0.1

# filtr dolnoprzepustowy Butterwortha 2 rzędu z częstością odcięcia 40 Hz
[d,c] = butter(2,40, btype='lowpass', fs=Fs)
charkterystyki(c,d,f,T,Fs)

# filtr pasmowo-zaporowy Czebyszewa II 
[f1,e] = cheby2(2, rs=25, Wn=(49,51), btype='bandstop', analog=0, output='ba',fs=Fs)
T = 0.3
charkterystyki(e,f1,f,T,Fs)

# Filtracja odprowadzeń Einthovena
sf_1 = filtfilt(b,a,syg_1)
sf_2 = filtfilt(b,a,syg_2)
sf_3 = filtfilt(b,a,syg_3)

sf_1 = filtfilt(d,c,sf_1)
sf_2 = filtfilt(d,c,sf_2)
sf_3 = filtfilt(d,c,sf_3)

sf_1 = filtfilt(f1,e,sf_1)
sf_2 = filtfilt(f1,e,sf_2)
sf_3 = filtfilt(f1,e,sf_3)

# Filtracja odprowadzeń Goldberga
sf_1_g = filtfilt(b,a,syg_1_g)
sf_2_g = filtfilt(b,a,syg_2_g)
sf_3_g = filtfilt(b,a,syg_3_g)

sf_1_g = filtfilt(d,c,sf_1_g)
sf_2_g = filtfilt(d,c,sf_2_g)
sf_3_g = filtfilt(d,c,sf_3_g)

sf_1_g = filtfilt(f1,e,sf_1_g)
sf_2_g = filtfilt(f1,e,sf_2_g)
sf_3_g = filtfilt(f1,e,sf_3_g)

plt.figure(figsize=(10,6), dpi= 100, facecolor='w', edgecolor='k')

x1 = 700 # czas od
x2 = 1000 # do

plt.subplot(3,2,1)
plt.plot(t[x1:x2], sf_1[x1:x2])
plt.title("Przefiltrowane fragmenty sygnału (Einthoven)")
plt.ylabel("Napięcie [mV]")
plt.grid(True)

plt.subplot(3,2,2)
plt.plot(t[x1:x2], sf_1_g[x1:x2])
plt.title("Przefiltrowane fragmenty sygnału (Goldberg)")
plt.grid(True)

plt.subplot(3,2,3)
plt.plot(t[x1:x2], sf_2[x1:x2])
plt.ylabel("Napięcie [mV]")
plt.grid(True)

plt.subplot(3,2,4)
plt.plot(t[x1:x2], sf_2_g[x1:x2])
plt.grid(True)

plt.subplot(3,2,5)
plt.plot(t[x1:x2], sf_3[x1:x2])
plt.ylabel("Napięcie [mV]")
plt.xlabel("Czas [s]")
plt.grid(True)

plt.subplot(3,2,6)
plt.plot(t[x1:x2], sf_3_g[x1:x2])
plt.xlabel("Czas [s]")
plt.grid(True)
plt.show()

"""Wybrano czysty fragment przefiltrowanego sygnału z pierwszego odprowadzenia Einthovena w celu identyfikacji poszczególnych załamków. Nastęnie zaznaczono oraz podpisano każdy z nich na poniższym wykresie:"""

plt.plot(t[800:900],sf_1[800:900])
plt.axvline(x=6.5,ymin=-2000,ymax=8000,color="olivedrab")
plt.axvline(x=6.605,ymin=-2000,ymax=8000,color="crimson")
plt.axvline(x=6.8,ymin=-2000,ymax=8000,color="darkorange")
plt.text(6.35, 450, "załamek P", color="olivedrab")
plt.text(6.63, 450, "QRS", color="crimson")
plt.text(6.83, 450, "załamek T", color="darkorange")
plt.grid(True)
plt.show()

"""##Ćwiczenie 5 - Detekcja pików R i powtarzalność cyklu

W celu rozpoznania pików R w sygnale wybrano kanał 3 (odprowadzenie Einthovena) z najsilniej wyróżniającymi się wobec tła pikami. Skorzystano z funkcji `FindSequence()` wyszukującej sekwencję odpowiednio wysokich wartości (oszacowano je na podstawie histogramu wszystkich wartości sygnału). Dla porównania skorzystano również z funkcji `find_peaks()` z biblioteki *scipy.signal*. 
"""

syg_samp = sf_3[700:1000]
t_samp = t[700:1000]

def FindSequence(syg, n):
  syg = list(syg)
  indexes = [syg.index(i) for i in syg if i >= 300]
  temp = [list(group) for group in mit.consecutive_groups(indexes)]
  result =  [group for group in temp if len(group) >= n]
  return result

R = FindSequence(syg_samp, 3)
print("Liczba wykrytych pików R:",len(R))
plt.plot(t_samp,syg_samp)
for i in R:
    plt.axvline(x=t_samp[i][1],ymin=-200,ymax=600,color="crimson")
plt.title('Przefiltrowany sygnał z pikami R zaznaczonymi kolorem czerwonym (FindSequence())')
plt.ylabel("Napięcie [mV]")
plt.xlabel('Czas [s]')
plt.grid(True)
plt.show()

#plt.hist(sf_1,bins=200)
#plt.show()

peaks, _ = find_peaks(syg_samp,300,prominence=1,)
plt.plot(t_samp, syg_samp)
plt.plot(t[peaks+700], syg_samp[peaks], "rx")
    #plt.axvline(x=i,ymin=-2000,ymax=8000,color="crimson")
plt.title('Przefiltrowany sygnał z pikami R zaznaczonymi kolorem czerwonym (find_peaks())')
plt.ylabel("Napięcie [mV]")
plt.xlabel('Czas [s]')
plt.grid(True)
plt.show()

"""Sprawdzono również powtarzalność sygnału w ramach jednego cyklu pracy serca. Nałożono na siebie wycinki sygnału wycięte wokół piku R, tak aby pik R znajdował się w tym samym miejscu na wykresie. Ilustrację wykonano dla wszystkich 3 odprowadzeń Einthovena i dla dwóch różnych sygnałów (odpoczynek oraz horror)."""

# wczytanie sygnału z oglądania horroru
with open('syg_horror.raw', 'rb') as f_out:
    sygh = np.fromfile(f_out, dtype='float32')
sygh *= 0.0715 # przemnożono sygnał zgodnie z informacją z pliku .xml
sygh = np.reshape(sygh,(len(sygh)//n_ch,n_ch))

VR = sygh[:,0]
VL = sygh[:,1]
VF = sygh[:,2]

#Einthoven
syg_1h = VL - VR
syg_2h = VF - VR
syg_3h = VF - VL

# Filtracja (horror)
sf_1h = filtfilt(b,a,syg_1h)
sf_2h = filtfilt(b,a,syg_2h)
sf_3h = filtfilt(b,a,syg_3h)

sf_1h = filtfilt(d,c,sf_1h)
sf_2h = filtfilt(d,c,sf_2h)
sf_3h = filtfilt(d,c,sf_3h)

sf_1h = filtfilt(f1,e,sf_1h)
sf_2h = filtfilt(f1,e,sf_2h)
sf_3h = filtfilt(f1,e,sf_3h)

Th = len(sf_1h)/Fs
th = np.arange(0,Th,dt)

def cykle(syg):
  all_R = FindSequence(syg, 3)
  peaks = [i[1] for i in all_R]
  cykle = []
  for i in peaks:
    cykle.append([i-20,i+20])
  for i in cykle:
    plt.plot(syg[i[0]:i[1]])

plt.figure(figsize=(10,6), dpi= 100, facecolor='w', edgecolor='k')
plt.subplot(3,2,1)
plt.title("Nałożone na siebie piki R sygnału\nzebranego w trakcie odpoczynku")
cykle(sf_1)
plt.subplot(3,2,2)
plt.title("Nałożone na siebie piki R sygnału\nzebranego w trakcie horroru")
cykle(sf_1h)
plt.subplot(3,2,3)
cykle(sf_2)
plt.subplot(3,2,4)
cykle(sf_2h)
plt.subplot(3,2,5)
cykle(sf_3)
plt.subplot(3,2,6)
cykle(sf_3h)

plt.show()

"""##Ćwiczenie 6 - Tętno
W tym ćwiczeniu napisano program, który wczytuje sygnał i na jego podstawie oblicza tętno. Dodatkowo wyrysowano również minutę sygnału oraz sprawdzono ile pików R pojawiło się w badanym czasie.
"""

min_len = 7680 #długość minuty
syg_samp = sf_3[min_len*3:min_len*4]
R_peaks = FindSequence(syg_samp, 3)
print("Liczba wykrytych pików R w minucie sygnału zebranego podczas odpoczynku:",len(R_peaks))

# wczytanie sygnału z wf-u
with open('syg_WF.raw', 'rb') as f_out:
    sygwf = np.fromfile(f_out, dtype='float32')
sygwf *= 0.0715 # przemnożono sygnał zgodnie z informacją z pliku .xml
sygwf = np.reshape(sygwf,(len(sygwf)//n_ch,n_ch))

VR = sygwf[:,0]
VL = sygwf[:,1]
VF = sygwf[:,2]

#Einthoven
syg_1wf = VL - VR
syg_2wf = VF - VR
syg_3wf = VF - VL

# Filtracja (wf)
sf_1wf = filtfilt(b,a,syg_1wf)
sf_2wf = filtfilt(b,a,syg_2wf)
sf_3wf = filtfilt(b,a,syg_3wf)

sf_1wf = filtfilt(d,c,sf_1wf)
sf_2wf = filtfilt(d,c,sf_2wf)
sf_3wf = filtfilt(d,c,sf_3wf)

sf_1wf = filtfilt(f1,e,sf_1wf)
sf_2wf = filtfilt(f1,e,sf_2wf)
sf_3wf = filtfilt(f1,e,sf_3wf)

Twf = len(sf_1wf)/Fs
twf = np.arange(0,Twf,dt)

all_R_peaks = FindSequence(sf_3, 3)
print('tętno (odpoczynek):', len(all_R_peaks)/(len(t)/min_len))
peaks, _ = find_peaks(sf_3,300,prominence=1)
print('tętno (odpoczynek):', len(sf_3[peaks])/(len(t)/min_len), "(metodą find_peaks)")

all_R_peaks = FindSequence(sf_3h, 3)
print('tętno (horror):', len(all_R_peaks)/(len(th)/min_len))
peaks, _ = find_peaks(sf_3h,300,prominence=1)
print('tętno (horror):', len(sf_3h[peaks])/(len(th)/min_len), "(metodą find_peaks)")

all_R_peaks = FindSequence(sf_3wf, 3)
print('tętno (wf):', len(all_R_peaks)/(len(twf)/min_len))
peaks, _ = find_peaks(sf_3wf,300,prominence=1)
print('tętno (wf):', len(sf_3wf[peaks])/(len(twf)/min_len), "(metodą find_peaks)")

"""## Ćwiczenie 7 - Widmo sygnału EKG

W tym ćwiczeniu wyznaczono widmo zebranego sygnału EKG podczas odpoczynku dla trzech odprowadzeń Goldberga. Widmo estymowano z oknem Blackmana dla jednej minuty sygnału.
"""

# funkcja obliczająca widmo sygnału (periodogram)

def periodogram(s, okno , F_samp):
    s = s*okno
    N_fft = len(s)
    S = np.fft.rfft(s,N_fft)
    P = S*S.conj()/np.sum(okno**2)   
    P = P.real/Fs
    F = np.fft.rfftfreq(N_fft, 1/F_samp)
    if len(s)%2 ==0:
        P[1:-1] *=2
    else:
        P[1:] *=2
    return (F,P)

syg_samp = sf_1_g[min_len*3:min_len*4]

F1, P1 = periodogram(syg_samp, np.blackman(len(syg_samp)), Fs)
plt.stem(F1, P1, use_line_collection=True)
plt.title("Widmo sygnału z pierwszego odprowadzenia Goldberga")
plt.xlabel("Częstość [Hz]")
plt.ylabel("Moc [dB]")
plt.grid(True)
plt.show()

syg_samp2 = sf_2_g[min_len*3:min_len*4]
F2, P2 = periodogram(syg_samp2, np.blackman(len(syg_samp2)), Fs)
plt.stem(F2, P2, use_line_collection=True)
plt.title("Widmo sygnału z drugiego odprowadzenia Goldberga")
plt.xlabel("Częstość [Hz]")
plt.ylabel("Moc [dB]")
plt.grid(True)
plt.show()

syg_samp3 = sf_3_g[min_len*3:min_len*4]
F3, P3 = periodogram(syg_samp3, np.blackman(len(syg_samp3)), Fs)
plt.stem(F3, P3, use_line_collection=True)
plt.title("Widmo sygnału z trzeciego odprowadzenia Goldberga")
plt.xlabel("Częstość [Hz]")
plt.ylabel("Moc [dB]")
plt.grid(True)
plt.show()

"""## Ćwiczenie 8: HRV

Zmienność rytmu zatokowego (ang. heart rate variability – HRV) odnosi się do rytmu pracy serca generowanego przez węzeł zatokowy, będący podstawowym, fizjologicznym ośrodkiem bodźcotwórczym. Wyraża się ona uchwytnymi w badaniu elektrokardiograficznym różnicami długości odstępów pomiędzy szczytami załamków R następujących kolejno po sobie zespołów QRS pochodzenia zatokowego. Zmienność rytmu zatokowego jest wyrazem aktywności autonomicznego układu nerwowego i jego modulacji czynności mięśnia sercowego. Wśród czynników mających wpływ na częstotliwość pracy serca wymienia się m.in.: aktywność fizyczną, zmiany ciśnienia tętniczego krwi, oddychanie, ciepłotę ciała, poziom hormonów, stan emocjonalny, a nawet porę dnia. HRV jest cechą zależną od płci i zmienia się z wiekiem (1-3). [2]

W celu zbadania zmienności rytmu zatokowego napisano program przedstawiający interwały pomiędzy pikami R w postaci szeregu czasowego. Wybrano trzecie odprowadzenie Einthovena z uwagi na najsilniejsze wyróżnianie się pików na tle reszty sygnału.
"""

def intervals(syg):
  R_peaks = FindSequence(syg,3)
  peaks = [i[0] for i in R_peaks]
  cykle = []
  start = 0
  stop = 1
  while stop < len(peaks):
    cykle.append((peaks[stop]-peaks[start])/Fs)
    start += 1
    stop += 1
  czasy = [t[i] for i in peaks[:-1]]
  return czasy, cykle

czasy, cykle = intervals(sf_3)
czasy = [t[i] for i in peaks[:-1]]
plt.figure(figsize=(10,6), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(czasy, cykle)
plt.ylabel("Interwały czasowe R-R")
plt.xlabel("Czas")
plt.show()

"""Na koniec, wyestymowano widmo częstotliwościowe dla zebranych sygnałów. Próbki są pobierane w różnych odstępach, dlatego aby zinterpolować punkty na równomiernie próbkowanej siatce skorzystano z funkcji `scipy.interpolate.interp1d()`."""

def intervals(syg):
  R_peaks = FindSequence(syg,3)
  peaks = [i[0] for i in R_peaks]
  cykle = []
  start = 0
  stop = 1
  while stop < len(peaks):
    cykle.append((peaks[stop]-peaks[start])/Fs)
    start += 1
    stop += 1
  czasy = [t[i] for i in peaks[:-1]]
  return czasy, cykle

cykle = cykle - np.mean(cykle) # odejmujemy średnią długość cyklu
func = sc.interpolate.interp1d(czasy, cykle)
x = np.arange(czasy[0],czasy[-1],1/10)
hrv = func(x)
syg_out = np.fft.rfft(hrv)
f = np.fft.rfftfreq(len(hrv),1/10)

plt.figure(figsize=(10,6), dpi= 100, facecolor='w', edgecolor='k')
plt.stem(f, np.abs(syg_out)**2,use_line_collection=True)
plt.xlim(0,0.6)
plt.grid("True")
plt.show()

czasy, cykle = intervals(sf_3h)
cykle = cykle - np.mean(cykle) # odejmujemy średnią długość cyklu
func = sc.interpolate.interp1d(czasy, cykle)
x = np.arange(czasy[0],czasy[-1],1/10)
hrv = func(x)
syg_out = np.fft.rfft(hrv)
f = np.fft.rfftfreq(len(hrv),1/10)

plt.figure(figsize=(10,6), dpi= 100, facecolor='w', edgecolor='k')
plt.stem(f, np.abs(syg_out)**2,use_line_collection=True)
plt.xlim(0,0.6)
plt.grid("True")
plt.show()

czasy, cykle = intervals(sf_3wf)
cykle = cykle - np.mean(cykle) # odejmujemy średnią długość cyklu
func = sc.interpolate.interp1d(czasy, cykle)
x = np.arange(czasy[0],czasy[-1],1/10)
hrv = func(x)
syg_out = np.fft.rfft(hrv)
f = np.fft.rfftfreq(len(hrv),1/10)

plt.figure(figsize=(10,6), dpi= 100, facecolor='w', edgecolor='k')
plt.stem(f, np.abs(syg_out)**2,use_line_collection=True)
plt.xlim(0,0.6)
plt.grid("True")
plt.show()



"""## Literatura
[1] https://brain.fuw.edu.pl/edu/index.php/Pracownia_Sygna%C5%82%C3%B3w_Biologicznych/Zajecia_2_4#Rejestracja_i_analiza_sygna.C5.82u_EKG 

[2] http://www.czytelniamedyczna.pl/6185,zmienno-rytmu-zatokowego-hrv.html
"""