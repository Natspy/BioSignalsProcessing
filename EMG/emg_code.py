# -*- coding: utf-8 -*-
"""EMG

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KyatC1zv_64DXvyVP6kf3ZVa9T6ju3tL

#EMG

###Ćwiczenie 1 - Badanie zależności sygnału EMG od aktywności ruchowej mięśni rąk
"""

! pip3 install obci_readmanager

import numpy as np
import scipy as sc
import matplotlib.pyplot as plt
from  scipy.signal import freqz, group_delay
from  scipy.signal import lfilter, filtfilt
from  scipy.signal import firwin, firwin2   
from  scipy.signal import butter, buttord     
from  scipy.signal import cheby1, cheb1ord    
from  scipy.signal import cheby2, cheb2ord 
from  scipy.signal import find_peaks
import more_itertools as mit
import pandas as pd

# Wczytywanie sygnału

from obci_readmanager.signal_processing.read_manager import ReadManager
mgr = ReadManager("Natalia_test_reka.xml", "Natalia_test_reka.raw", "Natalia_test_reka.tag")
Fs = float(mgr.get_param("sampling_frequency"))
num_of_channels = int(mgr.get_param("number_of_channels"))
channels_names = mgr.get_param("channels_names")

syg = mgr.get_microvolt_samples()
R = mgr.get_channel_samples("R") * 0.0715
L = mgr.get_channel_samples("L") * 0.0715

T = len(R)/Fs
dt = 1/Fs
t = np.arange(0,T,dt)
tags = mgr.get_tags()

x1 = int(35*Fs) # od

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t[x1:],R[x1:],color="orange")
plt.title("Sygnał z prawej ręki (przed filtracją)")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()
plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t[x1:],L[x1:], color="cornflowerblue")
plt.title("Sygnał z lewej ręki (przed filtracją)")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

# Filtrowanie sygnału

filtered_channels = []
for channel in [R,L]:
  [b1,a1] = butter(1,25,fs=Fs, btype="highpass")
  sf = filtfilt(b1,a1,channel)
  [b2,a2] = cheby2(2, rs = 25, Wn = (49,51), btype="bandstop", analog=0, output="ba", fs=Fs)
  sf = filtfilt(b2,a2,sf) # Notch 50 Hz
  filtered_channels.append(sf)

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t[x1:],filtered_channels[0][x1:],color="orange")
plt.title("Przefiltrowany sygnał z prawej ręki")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t[x1:],filtered_channels[1][x1:],color="cornflowerblue")
plt.title("Przefiltrowany sygnał z lewej ręki")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

from obci_readmanager.signal_processing.smart_tags_manager import SmartTagsManager
from obci_readmanager.signal_processing.tags.smart_tag_definition import (SmartTagDurationDefinition, SmartTagEndTagDefinition)
from obci_readmanager.signal_processing.read_manager import ReadManager

# Wydzielenie tagów

tags_prawa = []
for i in range(len(tags)):
  temp = []
  if "Prawa" in tags[i].values():
    for tag in tags[i].values():
      if type(tag) == float:
        temp.append(tag)
  if len(temp) != 0:      
    tags_prawa.append(temp)  

tags_lewa = []
for i in range(len(tags)):
  temp = []
  if "Lewa" in tags[i].values():
    for tag in tags[i].values():
      if type(tag) == float:
        temp.append(tag)
  if len(temp) != 0:      
    tags_lewa.append(temp)  

x1 = int(135*Fs)
plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t[x1:],filtered_channels[0][x1:],color="orange")
plt.title("Przefiltrowany fragment sygnału z prawej ręki + zaznaczone tagi")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)

for i in tags_prawa[18:]:
  plt.fill_betweenx([-1500,1500], i[0],i[1], color="green", alpha=0.2)

plt.show()

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t[x1:],filtered_channels[1][x1:],color="cornflowerblue")
plt.title("Przefiltrowany fragment sygnału z lewej ręki + zaznaczone tagi")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)

for i in tags_lewa[17:]:
  plt.fill_betweenx([-1500,1500], i[0],i[1], color="green", alpha=0.2)

plt.show()

# Detekcja ruchów ręki

def FindSequence(syg, n):
  syg = list(syg)
  indexes = [syg.index(i) for i in syg if i >= 450]
  temp = [list(group) for group in mit.consecutive_groups(indexes)]
  result =  [group for group in temp if len(group) >= n]
  return result

'''
Korzystam z dogodnego fragmentu sygnału, ponieważ obiekt badawczy (ja)
kilka razy aktywował mięśnie nieodpowiedniej ręki,
przez co czasem występuje niepasująca aktywność mięśnia (poza tagiem).
Wykorzystuję fragment, w którym nie występują takie sytuacje, dla lepszej prezentacji wyników.
'''

ruchy_R = FindSequence(filtered_channels[0][x1:], 1)

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t[x1:], filtered_channels[0][x1:], color="orange")
for i in ruchy_R:
    plt.axvline(x=t[x1:][i][0],ymin=-200,ymax=600,color="red", ls=":")
plt.title('Przefiltrowany fragment sygnału z prawej ręki - wykryte ruchy zaznaczono kolorem czerwonym')
plt.ylabel("Napięcie [mV]")
plt.xlabel('Czas [s]')
plt.grid(True)

for i in tags_prawa[18:]:
  plt.fill_betweenx([-1500,1500], i[0],i[1], color="green", alpha=0.2)

plt.show()

ruchy_L = FindSequence(filtered_channels[1][x1:], 1)

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t[x1:],filtered_channels[1][x1:],color="cornflowerblue")
for i in ruchy_L:
    plt.axvline(x=t[x1:][i][0],ymin=-200,ymax=600,color="red", ls=":")
plt.title('Przefiltrowany fragment sygnału z lewej ręki - wykryte ruchy zaznaczono kolorem czerwonym')
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)

for i in tags_lewa[17:]:
  plt.fill_betweenx([-1500,1500], i[0],i[1], color="green", alpha=0.2)

plt.show()

# Wygładzanie sygnałów średnią biegnącą przy użyciu biblioteki pandas

R_power = pd.Series(filtered_channels[0]**2)
L_power = pd.Series(filtered_channels[1]**2)
x2 = int(35*Fs) # fragment (od)

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
R_win_len = R_power.rolling(int(0.1*Fs))
R_moving_mean = R_win_len.mean()
Rma = R_moving_mean.tolist()
plt.subplot(2,1,1)
plt.plot(t[x2:],Rma[x2:],color="orange")
plt.title("Przebieg średniej mocy sygnału z prawej ręki (górny wykres) oraz lewej ręki (dolny wykres)")
plt.ylabel("Napięcie [µV]")
plt.grid(True)

L_win_len = L_power.rolling(int(0.1*Fs))
L_moving_mean = L_win_len.mean()
Lma = L_moving_mean.tolist()
plt.subplot(2,1,2)
plt.plot(t[x2:],Lma[x2:])
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

# Detekcja ruchu ręki na sygnale wygładzonym średnią biegnącą

def FindSequence(syg, n):
  syg = list(syg)
  indexes = [syg.index(i) for i in syg if i >= 20000]
  temp = [list(group) for group in mit.consecutive_groups(indexes)]
  result =  [group for group in temp if len(group) >= n]
  return result

ruchy_R = FindSequence(Rma[x1:], 1)

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t[x1:], Rma[x1:], color="orange")
for i in ruchy_R:
    plt.axvline(x=t[x1:][i][0],ymin=-200,ymax=600,color="red", ls="dashed")
plt.title('Przefiltrowany fragment sygnału z prawej ręki - wykryte ruchy zaznaczono kolorem czerwonym')
plt.ylabel("Napięcie [mV]")
plt.xlabel('Czas [s]')
plt.grid(True)

for i in tags_prawa[18:]:
  plt.fill_betweenx([-1500,150000], i[0],i[1], color="green", alpha=0.2)

plt.show()

ruchy_L = FindSequence(Lma[x1:], 1)

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t[x1:],Lma[x1:],color="cornflowerblue")
for i in ruchy_L:
    plt.axvline(x=t[x1:][i][0],ymin=-200,ymax=600,color="red", ls="dashed")
plt.title('Przefiltrowany fragment sygnału z lewej ręki - wykryte ruchy zaznaczono kolorem czerwonym')
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)

for i in tags_lewa[17:]:
  plt.fill_betweenx([-1500,200000], i[0],i[1], color="green", alpha=0.2)

plt.show()

"""## Zależność parametrów sygnału EMG od obciązenia mięśnia 

"""

# wczytanie sygnału z obciążeniem

from obci_readmanager.signal_processing.read_manager import ReadManager
mgr = ReadManager("ksiazki.xml", "ksiazki.raw", "ksiazki.tag")
Fs = float(mgr.get_param("sampling_frequency"))
num_of_channels = int(mgr.get_param("number_of_channels"))
channels_names = mgr.get_param("channels_names")
syg = mgr.get_microvolt_samples()
L = mgr.get_channel_samples("L") * 0.0715

T = len(L)/Fs
dt = 1/Fs
t = np.arange(0,T,dt)
tags = mgr.get_tags()

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,L, color="cornflowerblue")
plt.title("Sygnał z lewej ręki - przed filtracją (wraz ze wzrostem obciążenia)")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

# filtrowanie sygnału

[b1,a1] = butter(1,25,fs=Fs, btype="highpass")
sf = filtfilt(b1,a1,L)
[b2,a2] = cheby2(2, rs = 25, Wn = (49,51), btype="bandstop", analog=0, output="ba", fs=Fs)
sf = filtfilt(b2,a2,sf) # Notch 50 Hz
filtered_L = sf

tags_lewa = []
for i in range(len(tags)):
  temp = []
  for tag in tags[i].values():
    if type(tag) == float:
      temp.append(tag)
  if len(temp) != 0:      
    tags_lewa.append(temp)  

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,filtered_L,color="cornflowerblue")

for i in tags_lewa:
  plt.fill_betweenx([-1500,1500], i[0],i[1], color="green", alpha=0.2)

plt.title("Przefiltrowany sygnał z lewej ręki wraz ze wzrostem obciążenia + tagi")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

"""###Obserwacje:

Wraz ze wzrostem obciążenia amplituda napięcia sygnału rośnie.
"""

# widmo sygnału w zależności od obciążenia

def periodogram(s, okno , F_samp):
    s = s*okno
    N_fft = len(s)
    S = np.fft.rfft(s,N_fft)
    P = S*S.conj()/np.sum(okno**2)   
    P = P.real/Fs
    F = np.fft.rfftfreq(N_fft, 1/F_samp)
    if len(s)%2 ==0:
        P[1:-1] *=2
    else:
        P[1:] *=2 
    return (F,P)

books = 1
for i in tags_lewa:
  F, P = periodogram(filtered_L[int(i[0]*Fs):int(i[1]*Fs)], np.blackman(len(filtered_L[int(i[0]*Fs):int(i[1]*Fs)])), Fs)
  std = np.std(filtered_L[int(i[0]*Fs):int(i[1]*Fs)])
  print("odchylenie standardowe: {}".format(round(std,3)))
  plt.stem(F, P, use_line_collection=True)
  plt.title("Widmo sygnału z obciążeniem - liczba książek: {}".format(books))
  plt.xlabel("Częstość [Hz]")
  plt.ylabel("Moc [dB]")
  plt.grid(True)
  books += 1
  plt.show()

"""###Wniosek:
Wraz ze wzrostem obciążenia widmo sygnału osiąga coraz wyższą moc.
"""

std = []
for i in tags_lewa:
  std.append(np.std(filtered_L[int(i[0]*Fs):int(i[1]*Fs)]))
plt.plot(range(1,6), std, color="orange")
plt.title("Wykres zależności odchylenia standardowego sygnału od obciążenia ręki")
plt.xlabel("Obciążenie - liczba książek")
plt.ylabel("Odchylenie standardowe")
plt.grid(True)
plt.show()

"""###Wniosek:
Odchylenie standardowe sygnału rośnie wraz ze wzrostem obciążenia. Występuje wprost proporcjonalna zależność, w przybliżeniu niemal liniowa.

## Ćwiczenie II: Analiza napięcia mięśni twarzy pod wpływem bodźców emocjonalnych
"""

# wczytywanie sygnału

from obci_readmanager.signal_processing.read_manager import ReadManager
mgr = ReadManager("natalia_twarz.xml", "natalia_twarz.raw", "natalia_twarz.tag")
Fs = float(mgr.get_param("sampling_frequency"))
num_of_channels = int(mgr.get_param("number_of_channels"))
channels_names = mgr.get_param("channels_names")
syg = mgr.get_microvolt_samples()

nos1 = mgr.get_channel_samples("nos1") * 0.0715 # zdegustowanie - labii nasi
nos2 = mgr.get_channel_samples("nos2") * 0.0715
nasi = nos1 - nos2
czolo1 = mgr.get_channel_samples("czolo1") * 0.0715 # zdziwienie - frontalis
czolo2 = mgr.get_channel_samples("czolo2") * 0.0715
fr = czolo1 - czolo2
corr1 = mgr.get_channel_samples("corr1") * 0.0715 # złość - corrugator
corr2 = mgr.get_channel_samples("corr2") * 0.0715
corr = corr1 - corr2

T = len(corr)/Fs
dt = 1/Fs
t = np.arange(0,T,dt)
tags = mgr.get_tags()

plt.figure(figsize=(14,3), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,nasi, color="cornflowerblue")
plt.title("Sygnał z mięśnia lev. labii nasi")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

plt.figure(figsize=(14,3), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,fr, color="limegreen")
plt.title("Sygnał z mięśnia frontalis")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

plt.figure(figsize=(14,3), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,corr, color="orange")
plt.title("Sygnał z mięśnia corrugator")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

# filtrowanie sygnałów

[b1,a1] = butter(1,30,fs=Fs, btype="highpass")
sf_nasi = filtfilt(b1,a1,nasi)
[b2,a2] = cheby2(2, rs = 25, Wn = (49,51), btype="bandstop", analog=0, output="ba", fs=Fs)
sf_nasi = filtfilt(b2,a2,sf_nasi) # Notch 50 Hz
[b3,a3] = butter(1,500,fs=Fs, btype="lowpass")
sf_nasi = filtfilt(b3,a3,sf_nasi)

sf_fr = filtfilt(b1,a1,fr)
sf_fr = filtfilt(b2,a2,sf_fr) # Notch 50 Hz
sf_fr = filtfilt(b3,a3,sf_fr)

sf_corr = filtfilt(b1,a1,corr)
sf_corr = filtfilt(b2,a2,sf_corr) # Notch 50 Hz
sf_corr = filtfilt(b3,a3,sf_corr)

# wyrysowanie przefiltrowanych sygnałów

plt.figure(figsize=(14,3), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,sf_nasi, color="cornflowerblue")
plt.title("Przefiltrowany sygnał z mięśnia lev. labii nasi")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

plt.figure(figsize=(14,3), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,sf_fr, color="limegreen")
plt.title("Przefiltrowany sygnał z mięśnia frontalis")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

plt.figure(figsize=(14,3), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,sf_corr, color="orange")
plt.title("Przefiltrowany sygnał z mięśnia corrugator")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

# Wygładzanie średnią biegnącą przy użyciu pandas

sf_nasi_2 = pd.Series(sf_nasi**2)
sf_fr_2 = pd.Series(sf_fr**2)
sf_corr_2 = pd.Series(sf_corr**2)

nasi_win_len = sf_nasi_2.rolling(int(0.05*Fs))
nasi_moving_mean = nasi_win_len.mean()
nasi_ma = nasi_moving_mean.tolist()

plt.figure(figsize=(14,3), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,nasi_ma,color="cornflowerblue")
plt.title("Przebieg średniej mocy sygnału z mięśnia lev. labii nasi")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

fr_win_len = sf_fr_2.rolling(int(0.05*Fs))
fr_moving_mean = fr_win_len.mean()
fr_ma = fr_moving_mean.tolist()

plt.figure(figsize=(14,3), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,fr_ma,color="limegreen")
plt.title("Przebieg średniej mocy sygnału z mięśnia frontalis")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

corr_win_len = sf_corr_2.rolling(int(0.05*Fs))
corr_moving_mean = corr_win_len.mean()
corr_ma = corr_moving_mean.tolist()

#int(Fs*150):int(Fs*300)]

plt.figure(figsize=(14,3), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,corr_ma,color="orange")
plt.title("Przebieg średniej mocy sygnału z mięśnia corrugator")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

# rozdzielenie tagów na poszczególne emocje

tags_anger = []
for i in range(len(tags)):
  temp = []
  if "01f_an_c.bmp" in tags[i].values() or "02f_an_c.bmp" in tags[i].values():
    for tag in tags[i].values():
      if type(tag) == float:
        temp.append(tag)
  if len(temp) != 0:      
    tags_anger.append(temp)  

tags_supr = []
for i in range(len(tags)):
  temp = []
  if "01F_FE_C.bmp" in tags[i].values() or "02F_FE_C.bmp" in tags[i].values():
    for tag in tags[i].values():
      if type(tag) == float:
        temp.append(tag)
  if len(temp) != 0:      
    tags_supr.append(temp)  

tags_disg = []
for i in range(len(tags)):
  temp = []
  if "01F_DI_C.bmp" in tags[i].values() or "02f_di_c.bmp" in tags[i].values():
    for tag in tags[i].values():
      if type(tag) == float:
        temp.append(tag)
  if len(temp) != 0:      
    tags_disg.append(temp)  

print(tags_anger)
print(tags_disg)
print(tags_supr)

plt.figure(figsize=(14,3), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,nasi_ma,color="cornflowerblue")
plt.title('Przebieg średniej mocy sygnału z mięśnia lev. labii nasi + tagi bodźca "zdegustowanie"')
plt.ylabel("Napięcie [µV]")
plt.grid(True)

for i in tags_disg:
  plt.fill_betweenx([0,80000], i[0],i[1], color="pink", alpha=0.6)

plt.show()

plt.figure(figsize=(14,3), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,fr_ma,color="limegreen")
plt.title('Przebieg średniej mocy sygnału z mięśnia frontalis + tagi bodźca "zdziwienie"')
plt.ylabel("Napięcie [µV]")
plt.grid(True)

for i in tags_supr:
  plt.fill_betweenx([0,15000], i[0],i[1], color="pink", alpha=0.6)

plt.show()

#int(Fs*150):int(Fs*300)]

plt.figure(figsize=(14,3), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,corr_ma,color="orange")
plt.title('Przebieg średniej mocy sygnału z mięśnia corrugator + tagi bodźca "złość"')
plt.ylabel("Napięcie [µV]")
plt.grid(True)

for i in tags_anger:
  plt.fill_betweenx([0,500000], i[0],i[1], color="pink", alpha=0.6)

plt.show()

# Powtarzalność aktywacji mięśni w części aktywnej eksperymentu

plt.figure(figsize=(9,4), dpi= 100, facecolor='w', edgecolor='k')
for i in tags_disg:
  if i[0]>=147: # pierwszy tag emocji "zdegustowanie" pojawił się w 147s
    base_corr = np.mean(nasi_ma[int((i[0]-1)*Fs):int((i[0])*Fs)]) # baseline correction
    plt.plot(nasi_ma[int((i[0]-1)*Fs):int((i[1]+1)*Fs)] - base_corr) 
plt.grid(True)
plt.title('Powtarzalność aktywacji mięśnia lev. labii nasi przy bodźcu "zdegustowanie"')
plt.ylabel("Napięcie [µV]")    
plt.show() 

plt.figure(figsize=(9,4), dpi= 100, facecolor='w', edgecolor='k')
for i in tags_supr:
  if i[0]>=152: # pierwszy tag emocji "zdziwienie" pojawił się w 152s
    base_corr = np.mean(fr_ma[int((i[0]-1)*Fs):int((i[0])*Fs)])  # baseline correction
    plt.plot(fr_ma[int((i[0]-1)*Fs):int((i[1]+1)*Fs)] - base_corr)
plt.grid(True)
plt.title('Powtarzalność aktywacji mięśnia frontalis przy bodźcu "zdziwienie"')
plt.ylabel("Napięcie [µV]")    
plt.show()       

plt.figure(figsize=(9,4), dpi= 100, facecolor='w', edgecolor='k')
for i in tags_anger:
  if i[0]>=156: # pierwszy tag emocji "złość" pojawił się w 156s
    base_corr = np.mean(corr_ma[int((i[0]-1)*Fs):int((i[0])*Fs)]) # baseline correction
    plt.plot(corr_ma[int((i[0]-1)*Fs):int((i[1]+1)*Fs)] - base_corr)
plt.grid(True)
plt.title('Powtarzalność aktywacji mięśnia corrugator przy bodźcu "złość"')
plt.ylabel("Napięcie [µV]")    
plt.show()

"""###Wniosek:

W części aktywnej eksperymentu obiekt badawczy wykazał powtarzalną aktywność mięśni związaną z działającym bodźcem. Najsilniejsza powtarzalność wystąpiła podczas aktywacji mięśnia frontalis przy emocji "zdziwienie".
"""

# Powtarzalność aktywacji mięśni w części biernej eksperymentu

for i in tags_disg:
  if i[0]<=147:
    base_corr = np.mean(nasi_ma[int((i[0]-1)*Fs):int((i[0])*Fs)]) # baseline correction
    plt.plot(nasi_ma[int((i[0]-1)*Fs):int((i[1]+1)*Fs)] - base_corr)
plt.grid(True)
plt.title('Powtarzalność aktywacji mięśnia lev. labii nasi\nprzy bodźcu "zdegustowanie" - część bierna')
plt.ylabel("Napięcie [µV]")    
plt.show() 

for i in tags_supr:
  if i[0]<=152:
    base_corr = np.mean(fr_ma[int((i[0]-1)*Fs):int((i[0])*Fs)])  # baseline correction
    plt.plot(fr_ma[int((i[0]-1)*Fs):int((i[1]+1)*Fs)] - base_corr)
plt.grid(True)
plt.title('Powtarzalność aktywacji mięśnia frontalis\nprzy bodźcu "zdziwienie" - część bierna')
plt.ylabel("Napięcie [µV]")    
plt.show()       

for i in tags_anger:
  if i[0]<=156:
    base_corr = np.mean(corr_ma[int((i[0]-1)*Fs):int((i[0])*Fs)]) # baseline correction
    plt.plot(corr_ma[int((i[0]-1)*Fs):int((i[1]+1)*Fs)] - base_corr)
plt.grid(True)
plt.title('Powtarzalność aktywacji mięśnia corrugator\nprzy bodźcu "złość" - część bierna')
plt.ylabel("Napięcie [µV]")    
plt.show()

"""###Wniosek:

W części biernej eksperymentu obiekt badawczy nie wykazał powtarzalnej aktywacji mięśni. Dla niektórych mięśni wystąpiły sporadyczne skurcze.


"""