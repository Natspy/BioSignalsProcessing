# -*- coding: utf-8 -*-
"""EOG

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GXSydgunR5LtYS7KrFfp4nZ5TiSd8Jww

## EOG
### Ćwiczenie 1
Wczytywanie sygnału oraz wstępna analiza
"""

! pip3 install obci_readmanager

import numpy as np
import scipy as sc
import matplotlib.pyplot as plt
from  scipy.signal import freqz, group_delay
from  scipy.signal import lfilter, filtfilt
from  scipy.signal import firwin, firwin2   
from  scipy.signal import butter, buttord     
from  scipy.signal import cheby1, cheb1ord    
from  scipy.signal import cheby2, cheb2ord 
from  scipy.signal import find_peaks
import more_itertools as mit
import pandas as pd

# Wczytywanie sygnału

from obci_readmanager.signal_processing.read_manager import ReadManager
mgr = ReadManager("syg_eog_ws.xml", "syg_eog_ws.raw", "syg_eog_ws.tag")
Fs = float(mgr.get_param("sampling_frequency"))
num_of_channels = int(mgr.get_param("number_of_channels"))
channels_names = mgr.get_param("channels_names")

syg = mgr.get_microvolt_samples()

right = mgr.get_channel_samples("right") * 0.0715
left = mgr.get_channel_samples("left") * 0.0715
up = mgr.get_channel_samples("up") * 0.0715
down = mgr.get_channel_samples("dol") * 0.0715

# montaż
poz = right - left
pion = up - down 

T = len(poz)/Fs
dt = 1/Fs
t = np.arange(0,T,dt)
tags = mgr.get_tags()

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,poz,color="orange")
plt.title("Sygnał EOG w poziomie (przed filtracją)")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()
plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,pion, color="cornflowerblue")
plt.title("Sygnał EOG w pionie (przed filtracją)")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

# rozdzielenie tagów
def find_tags(name, tags):
  for tag in tags:
    if tag["name"] == name:
      return [value for value in tag.values() if type(value) == float]

tags_wahadlo = find_tags("wahadlo", tags)    
tags_szachownica = find_tags("szachownica", tags)    
tags_pasek = find_tags("pasek", tags)    
tags_tekst = find_tags("tekst", tags) 

print("wahadlo:", tags_wahadlo)
print("szachownica:", tags_szachownica)
print("pasek:", tags_pasek)
print("tekst:", tags_tekst)

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,poz,color="orange")
plt.title("Sygnał EOG w poziomie (przed filtracją) + zaznaczone tagi")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)

plt.fill_betweenx([15000,18500], tags_wahadlo[0], tags_wahadlo[1], color="limegreen", alpha=0.2)
plt.fill_betweenx([15000,18500], tags_szachownica[0], tags_szachownica[1], color="yellow", alpha=0.2)
plt.fill_betweenx([15000,18500], tags_pasek[0], tags_pasek[1], color="cyan", alpha=0.2)
plt.fill_betweenx([15000,18500], tags_tekst[0], tags_tekst[1], color="pink", alpha=0.4)

from matplotlib.lines import Line2D
custom_lines = [Line2D([0], [0], color="limegreen", alpha=0.2, lw=4),
                Line2D([0], [0], color="yellow", alpha=0.2, lw=4),
                Line2D([0], [0], color="cyan", alpha=0.2, lw=4),
                Line2D([0], [0], color="pink", alpha=0.4, lw=4)]

plt.legend(custom_lines, ['wahadło', 'szachownica', 'paski', 'tekst'])               

plt.show()

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,pion, color="cornflowerblue")
plt.title("Sygnał EOG w pionie (przed filtracją) + zaznaczone tagi")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)

plt.fill_betweenx([-4300,-2000], tags_wahadlo[0], tags_wahadlo[1], color="limegreen", alpha=0.2)
plt.fill_betweenx([-4300,-2000], tags_szachownica[0], tags_szachownica[1], color="yellow", alpha=0.2)
plt.fill_betweenx([-4300,-2000], tags_pasek[0], tags_pasek[1], color="cyan", alpha=0.2)
plt.fill_betweenx([-4300,-2000], tags_tekst[0], tags_tekst[1], color="pink", alpha=0.4)

custom_lines = [Line2D([0], [0], color="limegreen", alpha=0.2, lw=4),
                Line2D([0], [0], color="yellow", alpha=0.2, lw=4),
                Line2D([0], [0], color="cyan", alpha=0.2, lw=4),
                Line2D([0], [0], color="pink", alpha=0.4, lw=4)]

plt.legend(custom_lines, ['wahadło', 'szachownica', 'paski', 'tekst'])  

plt.show()

x1 = int(tags_wahadlo[0]*Fs) # fragmenty
x2 = int(tags_wahadlo[1]*Fs)

# filtrowanie sygnału po zadanym tagu
def tag_filter(tag, title, color):
  for f in [0.1, 0.5, 1, 2, 3, 4]:
    filtered_channels = []
    for channel in [poz, pion]:
      [b1,a1] = butter(2,f,fs=Fs, btype="highpass")
      sf = filtfilt(b1,a1,channel)
      [b2,a2] = cheby2(2, rs = 25, Wn = (49,51), btype="bandstop", analog=0, output="ba", fs=Fs)
      sf = filtfilt(b2,a2,sf) # Notch 50 Hz
      filtered_channels.append(sf)

    x1 = int(tag[0]*Fs + (20*Fs)) # fragmenty
    x2 = int(tag[1]*Fs - (20*Fs))

    plt.figure(figsize=(11,3), dpi= 100, facecolor='w', edgecolor='k')

    plt.subplot(1,2,1)
    plt.plot(t[x1:x2],filtered_channels[0][x1:x2],color="orange")
    plt.title("Przefiltrowany fragment sygnału w poziomie\n(filtr górnoprzepustowy {} Hz + Notch) - {}".format(f,title))
    plt.ylabel("Napięcie [µV]")
    plt.grid(True)

    plt.fill_betweenx([-150,150], tag[0]+20, tag[1]-20, color=color, alpha=0.2)

    plt.subplot(1,2,2)
    plt.plot(t[x1:x2],filtered_channels[1][x1:x2],color="cornflowerblue")
    plt.title("Przefiltrowany fragment sygnału w pionie\n(filtr górnoprzepustowy {} Hz + Notch) - {}".format(f,title))
    plt.xlabel("Czas [s]")
    plt.ylabel("Napięcie [µV]")
    plt.grid(True)

    plt.fill_betweenx([-150,150], tag[0]+20, tag[1]-20, color=color, alpha=0.2)

    plt.show()

tag_filter(tags_wahadlo, "wahadło", "limegreen")

tag_filter(tags_szachownica, "szachownica", "yellow")

tag_filter(tags_pasek, "pasek", "cyan")

tag_filter(tags_tekst, "tekst", "PaleVioletRed")

x1 = int(tags_pasek[0]*Fs) # fragmenty
x2 = int(tags_pasek[1]*Fs)

filtered_channels = []
for channel in [poz, pion]:
  [b1,a1] = butter(2,0.1,fs=Fs, btype="highpass") # górnoprzepustowy 1 Hz
  sf = filtfilt(b1,a1,channel)
  [b2,a2] = cheby2(2, rs = 25, Wn = (49,51), btype="bandstop", analog=0, output="ba", fs=Fs)
  sf = filtfilt(b2,a2,sf) # Notch 50 Hz
  filtered_channels.append(sf)


[b1,a1] = butter(2,15,fs=Fs, btype="lowpass")

sf_poz_15 =  filtfilt(b1,a1,filtered_channels[0])
sf_pion_15 =  filtfilt(b1,a1,filtered_channels[1])

[b1,a1] = butter(2,30,fs=Fs, btype="lowpass")

sf_poz_30 =  filtfilt(b1,a1,filtered_channels[0])
sf_pion_30 =  filtfilt(b1,a1,filtered_channels[1])

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')

plt.plot(t[x1:x2],sf_poz_30[x1:x2],color="limegreen")
plt.plot(t[x1:x2],sf_poz_15[x1:x2],color="orange")
plt.title("Przefiltrowany fragment sygnału w poziomie (filtr dolnoprzepustowy) - wahadło")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.xlim((200,202))
plt.grid(True)

custom_lines = [Line2D([0], [0], color="limegreen", lw=4),
                Line2D([0], [0], color="orange", lw=4)]
plt.legend(custom_lines, ['30 Hz', '15 Hz'])    

plt.show()

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')

plt.plot(t[x1:x2],sf_pion_30[x1:x2],color="cornflowerblue")
plt.plot(t[x1:x2],sf_pion_15[x1:x2],color="pink")
plt.title("Przefiltrowany fragment sygnału w pionie (filtr dolnoprzepustowy) - wahadło")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)

custom_lines = [Line2D([0], [0], color="cornflowerblue", lw=4),
                Line2D([0], [0], color="pink", lw=4)]
plt.legend(custom_lines, ['30 Hz', '15 Hz'])   

plt.show()

"""### Ćwiczenie 2 - EOG kwadraty"""

# Wczytywanie sygnału

from obci_readmanager.signal_processing.read_manager import ReadManager
mgr = ReadManager("eog_kwadraty.xml", "eog_kwadraty.raw", "eog_kwadraty.tag")
Fs = float(mgr.get_param("sampling_frequency"))
num_of_channels = int(mgr.get_param("number_of_channels"))
channels_names = mgr.get_param("channels_names")

syg = mgr.get_microvolt_samples()

hor = mgr.get_channel_samples("hor") * 0.0715
ver = mgr.get_channel_samples("ver") * 0.0715

T = len(hor)/Fs
dt = 1/Fs
t = np.arange(0,T,dt)
tags = mgr.get_tags()

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,hor,color="orange")
plt.title("Sygnał EOG w poziomie (przed filtracją)")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()
plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,ver, color="cornflowerblue")
plt.title("Sygnał EOG w pionie (przed filtracją)")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

# filtrowanie sygnału

filtered_channels = []
for channel in [hor, ver]:
  [b0,a0] = butter(2,25,fs=Fs, btype="lowpass") # dolnoprzepustowy 25 Hz
  sf = filtfilt(b0,a0,channel)
  [b1,a1] = butter(2,0.1,fs=Fs, btype="highpass") # górnoprzepustowy 0.1 Hz
  sf = filtfilt(b1,a1,channel)
  [b2,a2] = cheby2(2, rs = 25, Wn = (49,51), btype="bandstop", analog=0, output="ba", fs=Fs)
  sf = filtfilt(b2,a2,sf) # Notch 50 Hz
  filtered_channels.append(sf)

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,filtered_channels[0],color="orange")
plt.title("Przefiltrowany fragment sygnału w poziomie (filtr dolnoprzepustowy 25 Hz, górnoprzepustowy 0.1 Hz + Notch)")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,filtered_channels[1],color="cornflowerblue")
plt.title("Przefiltrowany fragment sygnału w pionie (filtr dolnoprzepustowy 25 Hz, górnoprzepustowy 0.1 Hz + Notch)")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

# Wygładzanie średnią biegnącą

hor_power = pd.Series(filtered_channels[0]**2)
ver_power = pd.Series(filtered_channels[1]**2)

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
hor_win_len = hor_power.rolling(int(0.1*Fs))
hor_moving_mean = hor_win_len.mean()
hor_ma = hor_moving_mean.tolist()
plt.subplot(2,1,1)
plt.plot(t,hor_ma,color="orange")
plt.title("Przebieg średniej mocy sygnału w poziomie (górny wykres) oraz w pionie (dolny wykres)")
plt.ylabel("Napięcie [µV]")
plt.grid(True)

ver_win_len = ver_power.rolling(int(0.1*Fs))
ver_moving_mean = ver_win_len.mean()
ver_ma = ver_moving_mean.tolist()
plt.subplot(2,1,2)
plt.plot(t,ver_ma)
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)
plt.show()

def find_tags2(name, tags):
  result = []
  for tag in tags:
    if tag["name"] == name:
      result.append([value for value in tag.values() if type(value) == float])
  return result     

tags_middle = find_tags2("middle", tags)    
tags_up = find_tags2("gora", tags)    
tags_right = find_tags2("prawo", tags)    
tags_left = find_tags2("lewo", tags) 
tags_down = find_tags2("dol", tags) 

print("środek:", tags_middle)
print("góra:", tags_up)
print("dół:", tags_down)
print("prawo:", tags_right)
print("lewo:", tags_left)

# Wykresy wygładzonych sygnałów wraz z tagami

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,hor_ma,color="orange")
plt.title("Sygnał EOG w poziomie (wygładzony) + zaznaczone tagi")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)

for i in tags_middle:
  plt.fill_betweenx([0,80000], i[0], i[1], color="limegreen", alpha=0.2)
for i in tags_up:
  plt.fill_betweenx([0,80000], i[0], i[1], color="yellow", alpha=0.2)
for i in tags_down:  
  plt.fill_betweenx([0,80000], i[0], i[1], color="cyan", alpha=0.2)
for i in tags_right:
  plt.fill_betweenx([0,80000], i[0], i[1], color="pink", alpha=0.4)
for i in tags_left:
  plt.fill_betweenx([0,80000], i[0], i[1], color="black", alpha=0.2)  

from matplotlib.lines import Line2D
custom_lines = [Line2D([0], [0], color="limegreen", alpha=0.2, lw=4),
                Line2D([0], [0], color="yellow", alpha=0.2, lw=4),
                Line2D([0], [0], color="cyan", alpha=0.2, lw=4),
                Line2D([0], [0], color="pink", alpha=0.4, lw=4),
                Line2D([0], [0], color="black", alpha=0.2, lw=4)]

plt.legend(custom_lines, ['środek', 'góra', 'dół', 'prawo', 'lewo'])               
plt.show()

plt.figure(figsize=(11,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t,ver_ma, color="cornflowerblue")
plt.title("Sygnał EOG w pionie (wygładzony) + zaznaczone tagi")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.grid(True)

for i in tags_middle:
  plt.fill_betweenx([0,2.5*1e6], i[0], i[1], color="limegreen", alpha=0.2)
for i in tags_up:
  plt.fill_betweenx([0,2.5*1e6], i[0], i[1], color="yellow", alpha=0.2)
for i in tags_down:  
  plt.fill_betweenx([0,2.5*1e6], i[0], i[1], color="cyan", alpha=0.2)
for i in tags_right:
  plt.fill_betweenx([0,2.5*1e6], i[0], i[1], color="pink", alpha=0.4)
for i in tags_left:
  plt.fill_betweenx([0,2.5*1e6], i[0], i[1], color="black", alpha=0.2)  

from matplotlib.lines import Line2D
custom_lines = [Line2D([0], [0], color="limegreen", alpha=0.2, lw=4),
                Line2D([0], [0], color="yellow", alpha=0.2, lw=4),
                Line2D([0], [0], color="cyan", alpha=0.2, lw=4),
                Line2D([0], [0], color="pink", alpha=0.4, lw=4),
                Line2D([0], [0], color="black", alpha=0.2, lw=4)]

plt.legend(custom_lines, ['środek', 'góra', 'dół', 'prawo', 'lewo'])               
plt.show()

# podzielenie tagów na sekwencję 'middle - not_middle - middle'

def sequence(name):
  sequences = []
  for i in range(len(tags)):  
    temp = []
    if name in tags[i].values():
      temp.append(min(value for value in tags[i-1].values() if type(value) == float))
      temp.append(max(value for value in tags[i+1].values() if type(value) == float))
    if len(temp) > 0:  
      sequences.append(temp)
  return sequences    

def plot_seq(name,title):
  plt.figure(figsize=(13,3), dpi= 100, facecolor='w', edgecolor='k')
  sequences = sequence(name)

  plt.subplot(1,2,1)
  for i in sequences:
    plt.plot(filtered_channels[1][int(i[0]*Fs):int(i[1]*Fs)])
  plt.title("Nałożone fragmenty sygnału w pionie\nsekwencja 'środek-{}-środek'".format(title))
  plt.ylabel("Napięcie [µV]")
  plt.grid(True)

  plt.subplot(1,2,2)
  for i in sequences:
    plt.plot(filtered_channels[0][int(i[0]*Fs):int(i[1]*Fs)])
  plt.ylabel("Napięcie [µV]")
  plt.title("Nałożone fragmenty sygnału w poziomie\nsekwencja 'środek-{}-środek'".format(title))
  plt.grid(True)

  plt.show()

plot_seq("gora","góra")
plot_seq("dol","dół")

plot_seq("prawo","prawo")
plot_seq("lewo","lewo")

plt.figure(figsize=(13,3), dpi= 100, facecolor='w', edgecolor='k')

sequences_left = sequence("lewo")
for i in sequences_left:
  for j in filtered_channels[1][int(i[0]*Fs):int(i[1]*Fs)]:
    if j > 700:
      blink = filtered_channels[1][int(i[0]*Fs):int(i[1]*Fs)]
      break
plt.plot(blink, color="darkorange")
plt.ylabel("Napięcie [µV]")
plt.title("Znaleziony przykład 'dobrego' mrugnięcia")
plt.grid(True)
plt.show()
print(blink)

blink = blink/np.linalg.norm(blink) # normalizacja

ver_norm = filtered_channels[1]/np.linalg.norm(filtered_channels[1])
detected_blinks = np.zeros(len(filtered_channels[1]))

Vblinks = []
start = 0
end = len(blink)
step = len(blink)
while end < len(t):
  Vblinks.append((np.dot(ver_norm[start:end], blink),start, end))
  start += step//2
  end = start + step

for i in Vblinks:
  if i[0] >= 0.03 or i[0] <= -0.03:
    detected_blinks[i[1]:i[2]] = filtered_channels[1][i[1]:i[2]]

x2 = int(27 * Fs)
x1 = int(12 * Fs)

plt.figure(figsize=(12,5), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(t[x1:x2],filtered_channels[1][x1:x2], color="cornflowerblue") 
plt.plot(t[x1:x2],detected_blinks[x1:x2], color="darkorange")
plt.grid(True)
plt.show()

# usuwanie mrugnięć
clean_ver = filtered_channels[1].copy()
for i in range(len(detected_blinks)):
  if detected_blinks[i] > 0:
    clean_ver[i] = 0

"""### Wyszukiwanie wzorca dla każdego rodzaju sakkady """

sequences = sequence("prawo")

for i in sequences:
  i[0] += 0.4
  i[1] -= 0.15

num = 0
for i in sequences:
  num += 1
  if num == 6: # "dobra" przykładowa sakada w prawo
    eg_saccade_hor_R = filtered_channels[0][int(i[0]*Fs):int(i[1]*Fs)]

sequences = sequence("lewo")

for i in sequences:
  i[0] += 0.4
  i[1] -= 0.15

num = 0
for i in sequences:
  num += 1
  if num == 10: # "dobra" przykładowa sakada w lewo
    eg_saccade_hor_L = filtered_channels[0][int(i[0]*Fs):int(i[1]*Fs)]

sequences = sequence("gora")

for i in sequences:
  i[0] += 0.4
  i[1] -= 0.15

num = 0
for i in sequences:

  num += 1
  if num == 3: # "dobra" przykładowa sakada w górę
    eg_saccade_ver_UP = filtered_channels[1][int(i[0]*Fs):int(i[1]*Fs)]

sequences = sequence("dol")

for i in sequences:
  i[0] += 0.4
  i[1] -= 0.15

num = 0
for i in sequences:
  num += 1
  if num == 7: # "dobra" przykładowa sakada w dół
    eg_saccade_ver_DOWN = filtered_channels[1][int(i[0]*Fs):int(i[1]*Fs)]

eg_saccade_hor_R = eg_saccade_hor_R/np.linalg.norm(eg_saccade_hor_R)
plt.plot(eg_saccade_hor_R)
plt.grid(True)
plt.show()

eg_saccade_hor_L = eg_saccade_hor_L/np.linalg.norm(eg_saccade_hor_L)
plt.plot(eg_saccade_hor_L)
plt.grid(True)
plt.show()

eg_saccade_ver_DOWN = eg_saccade_ver_DOWN/np.linalg.norm(eg_saccade_ver_DOWN)
plt.plot(eg_saccade_ver_DOWN)
plt.grid(True)
plt.show()

eg_saccade_ver_UP = eg_saccade_ver_UP/np.linalg.norm(eg_saccade_ver_UP)
plt.plot(eg_saccade_ver_UP)
plt.grid(True)
plt.show()

"""### Wykrywanie sakkad z pomocą posiadanych wzorców


"""

hor = filtered_channels[0]/np.linalg.norm(filtered_channels[0])
ver = filtered_channels[1]/np.linalg.norm(filtered_channels[1])

detected_hor = np.zeros(len(filtered_channels[0]))
detected_ver = np.zeros(len(filtered_channels[1]))

HR = []
HL = []

start = 0
end = len(eg_saccade_hor_R)
step = len(eg_saccade_hor_R)
while end < len(t):
  HR.append((np.dot(hor[start:end], eg_saccade_hor_R),start, end))
  HL.append((np.dot(hor[start:end], eg_saccade_hor_L),start, end))
  start += step//2
  end = start + step
  end2 = start + step  

for i in [HR, HL]:
  for item in i:
    if item[0] >= 0.05 or item[0] <= -0.05:
      detected_hor[item[1]:item[2]] = filtered_channels[0][item[1]:item[2]]

tags_R = sequence("prawo")
tags_L = sequence("lewo")

plt.figure(figsize=(14,6), dpi= 100, facecolor='w', edgecolor='k')
plt.grid(True)
plt.title("Sygnał w poziomie - duże ujemne lub dodatnie wartości to wykryte sakady")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
plt.plot(t,filtered_channels[0], color="cornflowerblue") 
plt.plot(t,detected_hor, color="darkorange")
for i in tags_R:  
  plt.fill_betweenx([-300,250], i[0], i[1], color="pink", alpha=0.6)
for i in tags_L:  
  plt.fill_betweenx([-300,250], i[0], i[1], color="limegreen", alpha=0.2) 

custom_lines = [Line2D([0], [0], color="limegreen", alpha=0.2, lw=4),
                Line2D([0], [0], color="pink", alpha=0.6, lw=4),
                Line2D([0], [0], color="darkorange", lw=4)]

plt.legend(custom_lines, ['sakkady dodatnie (tagi)', 'sakkady ujemne (tagi)', 'wykryte sakkady']) 
plt.show()

VU = []
VD = []

start = 0
end = len(eg_saccade_ver_UP)
step = len(eg_saccade_ver_UP)
while end < len(t):
  VU.append((np.dot(ver[start:end], eg_saccade_ver_UP),start, end))
  VD.append((np.dot(ver[start:end], eg_saccade_ver_DOWN),start, end))
  start += step//2
  end = start + step  

for i in [VU, VD]:
  for item in i:
    #if item[0] >= 0.05 and item[0] <= 0.08 or item[0] <= -0.05 and item[0] >= -0.07:
    if item[0] >= 0.03 and item[0] <= 0.07 or item[0] <= -0.03 and item[0] >= -0.07:
      detected_ver[item[1]:item[2]] = clean_ver[item[1]:item[2]]

tags_up = sequence("gora")
tags_down = sequence("dol")

plt.figure(figsize=(14,6), dpi= 100, facecolor='w', edgecolor='k')
plt.grid(True)
plt.title("Sygnał w pionie - duże ujemne lub dodatnie wartości to wykryte sakady")
plt.plot(t,clean_ver, color="cornflowerblue") 
plt.plot(t,detected_ver, color="darkorange")
plt.xlabel("Czas [s]")
plt.ylabel("Napięcie [µV]")
for i in tags_down:  
  plt.fill_betweenx([-700,1250], i[0], i[1], color="pink", alpha=0.6)
for i in tags_up:  
  plt.fill_betweenx([-700,1250], i[0], i[1], color="limegreen", alpha=0.2) 

custom_lines = [Line2D([0], [0], color="limegreen", alpha=0.2, lw=4),
                Line2D([0], [0], color="pink", alpha=0.6, lw=4),
                Line2D([0], [0], color="darkorange", lw=4)]

plt.legend(custom_lines, ['sakkady dodatnie (tagi)','sakkady ujemne (tagi)','wykryte sakkady']) 
plt.show()